# SECURITY BEST PRACTICES FOR ASP.NET Core

Securing applications involves everything from ensuring proper configurations to preventing sensitive data from being exposed.

To avoid exposing sensitive data, you should use not only HTTPS but also encrypt the data at rest, and refrain from storing sensitive data in an unencrypted form in a database or anywhere in the application.

You should also routinely monitor the activity logs generated by your application. Examining the logs can give you insights into security, performance, and other issues in your application.

## 1. Enforce HTTPS in ASP.NET Core

SSL, or Secure Sockets Layer, is a protocol that facilitates safe and secure communication between clients and servers over a network by enabling the communication to be encrypted.

You can enforce the use of HTTPS to secure your application by redirecting HTTP requests to HTTPS.

The following code snippet shows how you can configure HTTPS security for your application in the **Program.cs** file.

```c#
// Redirect HTTP requests to HTTPS
builder.Services.AddHttpsRedirection(options =>
{
    options.RedirectStatusCode = StatusCodes.Status307TemporaryRedirect;
    options.HttpsPort = 443;
});
```

## 2. Use HTTP Strict Transport Security in ASP.NET Core

HTTP Strict Transport Security, or HSTS, prevents downgrade protocol attacks and cookie hijacking by ensuring that the web server communicates using an HTTPS connection and by blocking all insecure HTTP connections. Note that the ASP.NET Core runtime engine adds the HSTS middleware by default.

```c#
// Use HTTP Strict Transport Security (HSTS)
builder.Services.AddHsts(options =>
{
   options.IncludeSubDomains = true;
   options.MaxAge = TimeSpan.FromDays(7);
});
```

## 3. Prevent cross-site request forgery attacks in ASP.NET Core

Cross-site request forgery attacks (CSRF) trick a user into performing malicious activities while the user is logged into an application.

These attacks are most commonly performed by tricking users with phishing emails to lure them to malicious websites, where they use an authenticated user’s privileges to steal funds from a victim's bank account, for example, or make online purchases using the victim’s credit card.

You can protect users of your ASP.NET Core application from CSRF attacks by using anti-forgery tokens. When you include anti-forgery tokens in your application, two different values are sent to the server with each POST. One of the values is sent as a browser cookie, and one is submitted as form data. Unless the server receives both values, it will refuse to allow the request to proceed.

```c#
// Use use anti-forgery tokens
builder.Services.AddAntiforgery(options =>
{
    options.FormFieldName = "ThisIsAnAntiForgeryField";
    options.HeaderName = "ThisIsAnAntiForgeryHeader";
    options.Cookie.Name = "ThisIsAnAntiForgeryCookie";
});
```

## 4. Prevent cross-site scripting in ASP.NET Core

Cross-site scripting (XSS) refers to the act of injecting a malicious script using input or form fields of a web page in your application, with the intent of stealing sensitive data such as login credentials or cookies.

When an attacker wants to launch an XSS attack, they often send a malicious link to a user and then attempt to entice the person to click on the link.

You can thwart cross-site scripting using URL encoding, HTML encoding, and regular expressions to validate and sanitize inputs.

## 5. Prevent SQL injection in ASP.NET Core

SQL injection is a major security concern.

SQL injection occurs when an attacker inserts malicious SQL commands within your dynamically created SQL queries.

Such attacks are enabled by security vulnerabilities in database queries, leading to exposure of sensitive information.

Prevent SQL injection by using stored procedures and parameterized queries in lieu of dynamic SQL queries, and by validating user input to remove potentially malicious characters.

## 6. Create custom error pages in ASP.NET Core

If you don’t implement proper error handling code in your application, you might inadvertently expose sensitive information such as configuration data, table names, or even social security numbers.

To avoid this, you can implement a custom error web page in your application so that whenever an error occurs, the custom page will display safe error messages instead of the potentially compromising error messages that your application might generate.

In addition to the custom error web page, you should create a custom exception filter by extending the ExceptionFilterAttribute class and overriding the OnException method. The code snippet below shows how to redirect the route to the custom error web page when an error occurs.

```c#
var result = new RedirectToRouteResult(
new RouteValueDictionary
{
    {"controller", "Error"}, {"action", "MyCustomError"}
});
```

Finally, write the following piece of code in the Program.cs file to register the exception handler with the request processing pipeline.

```c#
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/MyCustomError");
}
```

[Source](https://www.infoworld.com/article/3715456/6-security-best-practices-for-aspnet-core.html)
